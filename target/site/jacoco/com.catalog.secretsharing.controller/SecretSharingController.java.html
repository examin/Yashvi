<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SecretSharingController.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">shamir-secret-sharing</a> &gt; <a href="index.source.html" class="el_package">com.catalog.secretsharing.controller</a> &gt; <span class="el_source">SecretSharingController.java</span></div><h1>SecretSharingController.java</h1><pre class="source lang-java linenums">package com.catalog.secretsharing.controller;

import com.catalog.secretsharing.model.TestCaseInput;
import com.catalog.secretsharing.model.SecretResponse;
import com.catalog.secretsharing.model.Keys;
import com.catalog.secretsharing.model.RootPoint;
import com.catalog.secretsharing.service.SecretSharingService;
import com.fasterxml.jackson.databind.ObjectMapper;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;

import jakarta.validation.Valid;
import lombok.extern.slf4j.Slf4j;

import java.util.Map;
import java.util.HashMap;

/**
 * REST Controller for Shamir's Secret Sharing operations
 * 
 * This controller provides endpoints for calculating secrets from polynomial
 * root points using Shamir's Secret Sharing algorithm.
 */
@RestController
@RequestMapping(&quot;/api/secret-sharing&quot;)
@Tag(name = &quot;Secret Sharing&quot;, description = &quot;Shamir's Secret Sharing API endpoints&quot;)
<span class="nc" id="L39">@Slf4j</span>
public class SecretSharingController {
    
    private final SecretSharingService secretSharingService;
    private final ObjectMapper objectMapper;
    
    @Autowired
    public SecretSharingController(SecretSharingService secretSharingService,
<span class="nc" id="L47">                                  ObjectMapper objectMapper) {</span>
<span class="nc" id="L48">        this.secretSharingService = secretSharingService;</span>
<span class="nc" id="L49">        this.objectMapper = objectMapper;</span>
<span class="nc" id="L50">    }</span>
    
    /**
     * Calculate secret from JSON test case
     */
    @PostMapping(&quot;/calculate&quot;)
    @Operation(
        summary = &quot;Calculate secret from test case&quot;,
        description = &quot;Calculates the secret using Shamir's Secret Sharing algorithm from provided root points&quot;
    )
    @ApiResponses({
        @ApiResponse(responseCode = &quot;200&quot;, description = &quot;Secret calculated successfully&quot;),
        @ApiResponse(responseCode = &quot;400&quot;, description = &quot;Invalid input data&quot;),
        @ApiResponse(responseCode = &quot;500&quot;, description = &quot;Internal server error&quot;)
    })
    public ResponseEntity&lt;SecretResponse&gt; calculateSecret(
            @Valid @RequestBody TestCaseInput testCase) {
        
<span class="nc" id="L68">        log.info(&quot;Received secret calculation request with {} points&quot;, </span>
<span class="nc" id="L69">                testCase.getRootPointCount());</span>
        
        try {
<span class="nc" id="L72">            SecretResponse response = secretSharingService.calculateSecret(testCase);</span>
            
<span class="nc bnc" id="L74" title="All 2 branches missed.">            if (response.getSuccess()) {</span>
<span class="nc" id="L75">                log.info(&quot;Successfully calculated secret: {}&quot;, response.getSecret());</span>
<span class="nc" id="L76">                return ResponseEntity.ok(response);</span>
            } else {
<span class="nc" id="L78">                log.error(&quot;Failed to calculate secret: {}&quot;, response.getErrorMessage());</span>
<span class="nc" id="L79">                return ResponseEntity.badRequest().body(response);</span>
            }
            
<span class="nc" id="L82">        } catch (Exception e) {</span>
<span class="nc" id="L83">            log.error(&quot;Error processing secret calculation: {}&quot;, e.getMessage(), e);</span>
<span class="nc" id="L84">            SecretResponse errorResponse = SecretResponse.error(</span>
<span class="nc" id="L85">                &quot;Failed to process request: &quot; + e.getMessage(), </span>
<span class="nc" id="L86">                System.currentTimeMillis()</span>
            );
<span class="nc" id="L88">            return ResponseEntity.internalServerError().body(errorResponse);</span>
        }
    }
    
    /**
     * Calculate secret with verification using multiple point combinations
     */
    @PostMapping(&quot;/calculate-verified&quot;)
    @Operation(
        summary = &quot;Calculate secret with verification&quot;,
        description = &quot;Calculates secret and verifies consistency using different point combinations&quot;
    )
    public ResponseEntity&lt;SecretResponse&gt; calculateSecretWithVerification(
            @Valid @RequestBody TestCaseInput testCase) {
        
<span class="nc" id="L103">        log.info(&quot;Received verified secret calculation request&quot;);</span>
        
        try {
<span class="nc" id="L106">            SecretResponse response = secretSharingService.calculateSecretWithVerification(testCase);</span>
            
<span class="nc bnc" id="L108" title="All 2 branches missed.">            if (response.getSuccess()) {</span>
<span class="nc" id="L109">                return ResponseEntity.ok(response);</span>
            } else {
<span class="nc" id="L111">                return ResponseEntity.badRequest().body(response);</span>
            }
            
<span class="nc" id="L114">        } catch (Exception e) {</span>
<span class="nc" id="L115">            log.error(&quot;Error in verified calculation: {}&quot;, e.getMessage(), e);</span>
<span class="nc" id="L116">            SecretResponse errorResponse = SecretResponse.error(</span>
<span class="nc" id="L117">                &quot;Verification failed: &quot; + e.getMessage(), </span>
<span class="nc" id="L118">                System.currentTimeMillis()</span>
            );
<span class="nc" id="L120">            return ResponseEntity.internalServerError().body(errorResponse);</span>
        }
    }
    
    /**
     * Calculate secret from uploaded JSON file
     */
    @PostMapping(value = &quot;/calculate-from-file&quot;, consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    @Operation(
        summary = &quot;Calculate secret from uploaded JSON file&quot;,
        description = &quot;Upload a JSON file containing the test case and calculate the secret&quot;
    )
    public ResponseEntity&lt;SecretResponse&gt; calculateSecretFromFile(
            @Parameter(description = &quot;JSON file containing test case&quot;)
            @RequestParam(&quot;file&quot;) MultipartFile file) {
        
<span class="nc" id="L136">        log.info(&quot;Received file upload request: {}&quot;, file.getOriginalFilename());</span>
        
        try {
            // Validate file
<span class="nc bnc" id="L140" title="All 2 branches missed.">            if (file.isEmpty()) {</span>
<span class="nc" id="L141">                return ResponseEntity.badRequest().body(</span>
<span class="nc" id="L142">                    SecretResponse.error(&quot;File is empty&quot;, System.currentTimeMillis())</span>
                );
            }
            
<span class="nc bnc" id="L146" title="All 2 branches missed.">            if (!file.getOriginalFilename().toLowerCase().endsWith(&quot;.json&quot;)) {</span>
<span class="nc" id="L147">                return ResponseEntity.badRequest().body(</span>
<span class="nc" id="L148">                    SecretResponse.error(&quot;File must be a JSON file&quot;, System.currentTimeMillis())</span>
                );
            }
            
            // Parse JSON
<span class="nc" id="L153">            String jsonContent = new String(file.getBytes());</span>
<span class="nc" id="L154">            TestCaseInput testCase = objectMapper.readValue(jsonContent, TestCaseInput.class);</span>
            
            // Calculate secret
<span class="nc" id="L157">            SecretResponse response = secretSharingService.calculateSecret(testCase);</span>
            
<span class="nc bnc" id="L159" title="All 2 branches missed.">            if (response.getSuccess()) {</span>
<span class="nc" id="L160">                log.info(&quot;Successfully processed file and calculated secret: {}&quot;, response.getSecret());</span>
<span class="nc" id="L161">                return ResponseEntity.ok(response);</span>
            } else {
<span class="nc" id="L163">                return ResponseEntity.badRequest().body(response);</span>
            }
            
<span class="nc" id="L166">        } catch (Exception e) {</span>
<span class="nc" id="L167">            log.error(&quot;Error processing uploaded file: {}&quot;, e.getMessage(), e);</span>
<span class="nc" id="L168">            SecretResponse errorResponse = SecretResponse.error(</span>
<span class="nc" id="L169">                &quot;Failed to process file: &quot; + e.getMessage(), </span>
<span class="nc" id="L170">                System.currentTimeMillis()</span>
            );
<span class="nc" id="L172">            return ResponseEntity.badRequest().body(errorResponse);</span>
        }
    }
    
    /**
     * Run predefined test cases
     */
    @GetMapping(&quot;/test/{testNumber}&quot;)
    @Operation(
        summary = &quot;Run predefined test case&quot;,
        description = &quot;Runs one of the predefined test cases (1 or 2)&quot;
    )
    @ApiResponses({
        @ApiResponse(responseCode = &quot;200&quot;, description = &quot;Test completed successfully&quot;),
        @ApiResponse(responseCode = &quot;404&quot;, description = &quot;Test case not found&quot;)
    })
    public ResponseEntity&lt;SecretResponse&gt; runTestCase(
            @Parameter(description = &quot;Test case number (1 or 2)&quot;)
            @PathVariable int testNumber) {
        
<span class="nc" id="L192">        log.info(&quot;Running predefined test case: {}&quot;, testNumber);</span>
        
        try {
<span class="nc" id="L195">            TestCaseInput testCase = createTestCase(testNumber);</span>
            
<span class="nc bnc" id="L197" title="All 2 branches missed.">            if (testCase == null) {</span>
<span class="nc" id="L198">                return ResponseEntity.notFound().build();</span>
            }
            
<span class="nc" id="L201">            SecretResponse response = secretSharingService.calculateSecret(testCase);</span>
            
<span class="nc bnc" id="L203" title="All 2 branches missed.">            if (response.getSuccess()) {</span>
<span class="nc" id="L204">                log.info(&quot;Test case {} completed successfully. Secret: {}&quot;, </span>
<span class="nc" id="L205">                        testNumber, response.getSecret());</span>
<span class="nc" id="L206">                return ResponseEntity.ok(response);</span>
            } else {
<span class="nc" id="L208">                return ResponseEntity.badRequest().body(response);</span>
            }
            
<span class="nc" id="L211">        } catch (Exception e) {</span>
<span class="nc" id="L212">            log.error(&quot;Error running test case {}: {}&quot;, testNumber, e.getMessage(), e);</span>
<span class="nc" id="L213">            SecretResponse errorResponse = SecretResponse.error(</span>
<span class="nc" id="L214">                &quot;Test case failed: &quot; + e.getMessage(), </span>
<span class="nc" id="L215">                System.currentTimeMillis()</span>
            );
<span class="nc" id="L217">            return ResponseEntity.internalServerError().body(errorResponse);</span>
        }
    }
    
    /**
     * Get algorithm information
     */
    @GetMapping(&quot;/info&quot;)
    @Operation(
        summary = &quot;Get algorithm information&quot;,
        description = &quot;Returns information about the algorithm implementation&quot;
    )
    public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; getAlgorithmInfo() {
<span class="nc" id="L230">        Map&lt;String, Object&gt; info = new HashMap&lt;&gt;();</span>
<span class="nc" id="L231">        info.put(&quot;algorithm&quot;, &quot;Shamir's Secret Sharing&quot;);</span>
<span class="nc" id="L232">        info.put(&quot;method&quot;, &quot;Lagrange Interpolation&quot;);</span>
<span class="nc" id="L233">        info.put(&quot;precision&quot;, &quot;High precision using BigDecimal&quot;);</span>
<span class="nc" id="L234">        info.put(&quot;supportedBases&quot;, &quot;2-36&quot;);</span>
<span class="nc" id="L235">        info.put(&quot;description&quot;, secretSharingService.getAlgorithmInfo());</span>
<span class="nc" id="L236">        info.put(&quot;version&quot;, &quot;1.0.0&quot;);</span>
        
<span class="nc" id="L238">        return ResponseEntity.ok(info);</span>
    }
    
    /**
     * Health check endpoint
     */
    @GetMapping(&quot;/health&quot;)
    @Operation(
        summary = &quot;Health check&quot;,
        description = &quot;Simple health check endpoint&quot;
    )
    public ResponseEntity&lt;Map&lt;String, String&gt;&gt; healthCheck() {
<span class="nc" id="L250">        Map&lt;String, String&gt; status = new HashMap&lt;&gt;();</span>
<span class="nc" id="L251">        status.put(&quot;status&quot;, &quot;UP&quot;);</span>
<span class="nc" id="L252">        status.put(&quot;service&quot;, &quot;Secret Sharing Service&quot;);</span>
<span class="nc" id="L253">        status.put(&quot;timestamp&quot;, java.time.LocalDateTime.now().toString());</span>
        
<span class="nc" id="L255">        return ResponseEntity.ok(status);</span>
    }
    
    /**
     * Creates predefined test cases
     */
    private TestCaseInput createTestCase(int testNumber) {
<span class="nc bnc" id="L262" title="All 3 branches missed.">        switch (testNumber) {</span>
            case 1:
<span class="nc" id="L264">                return createTestCase1();</span>
            case 2:
<span class="nc" id="L266">                return createTestCase2();</span>
            default:
<span class="nc" id="L268">                return null;</span>
        }
    }
    
    /**
     * Creates test case 1
     */
    private TestCaseInput createTestCase1() {
<span class="nc" id="L276">        TestCaseInput testCase = new TestCaseInput();</span>
<span class="nc" id="L277">        testCase.setKeys(new Keys(4, 3));</span>
        
<span class="nc" id="L279">        testCase.addRootPoint(1, new RootPoint(1, &quot;10&quot;, &quot;4&quot;));</span>
<span class="nc" id="L280">        testCase.addRootPoint(2, new RootPoint(2, &quot;2&quot;, &quot;111&quot;));</span>
<span class="nc" id="L281">        testCase.addRootPoint(3, new RootPoint(3, &quot;10&quot;, &quot;12&quot;));</span>
<span class="nc" id="L282">        testCase.addRootPoint(6, new RootPoint(6, &quot;4&quot;, &quot;213&quot;));</span>
        
<span class="nc" id="L284">        return testCase;</span>
    }
    
    /**
     * Creates test case 2
     */
    private TestCaseInput createTestCase2() {
<span class="nc" id="L291">        TestCaseInput testCase = new TestCaseInput();</span>
<span class="nc" id="L292">        testCase.setKeys(new Keys(10, 7));</span>
        
<span class="nc" id="L294">        testCase.addRootPoint(1, new RootPoint(1, &quot;6&quot;, &quot;13444211440455345511&quot;));</span>
<span class="nc" id="L295">        testCase.addRootPoint(2, new RootPoint(2, &quot;15&quot;, &quot;aed7015a346d63&quot;));</span>
<span class="nc" id="L296">        testCase.addRootPoint(3, new RootPoint(3, &quot;15&quot;, &quot;6aeeb69631c227c&quot;));</span>
<span class="nc" id="L297">        testCase.addRootPoint(4, new RootPoint(4, &quot;16&quot;, &quot;e1b5e05623d881f&quot;));</span>
<span class="nc" id="L298">        testCase.addRootPoint(5, new RootPoint(5, &quot;8&quot;, &quot;316034514573652620673&quot;));</span>
<span class="nc" id="L299">        testCase.addRootPoint(6, new RootPoint(6, &quot;3&quot;, &quot;2122212201122002221120200210011020220200&quot;));</span>
<span class="nc" id="L300">        testCase.addRootPoint(7, new RootPoint(7, &quot;3&quot;, &quot;20120221122211000100210021102001201112121&quot;));</span>
<span class="nc" id="L301">        testCase.addRootPoint(8, new RootPoint(8, &quot;6&quot;, &quot;20220554335330240002224253&quot;));</span>
<span class="nc" id="L302">        testCase.addRootPoint(9, new RootPoint(9, &quot;12&quot;, &quot;45153788322a1255483&quot;));</span>
<span class="nc" id="L303">        testCase.addRootPoint(10, new RootPoint(10, &quot;7&quot;, &quot;1101613130313526312514143&quot;));</span>
        
<span class="nc" id="L305">        return testCase;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>