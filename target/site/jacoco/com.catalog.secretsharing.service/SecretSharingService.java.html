<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SecretSharingService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">shamir-secret-sharing</a> &gt; <a href="index.source.html" class="el_package">com.catalog.secretsharing.service</a> &gt; <span class="el_source">SecretSharingService.java</span></div><h1>SecretSharingService.java</h1><pre class="source lang-java linenums">package com.catalog.secretsharing.service;

import com.catalog.secretsharing.model.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import lombok.extern.slf4j.Slf4j;

import java.math.BigDecimal;
import java.util.List;
import java.util.ArrayList;
import java.util.stream.Collectors;

/**
 * Main service orchestrating the Shamir's Secret Sharing algorithm
 * 
 * This service coordinates the base decoding and Lagrange interpolation
 * to reconstruct the secret from encoded polynomial roots.
 */
@Service
<span class="fc" id="L20">@Slf4j</span>
public class SecretSharingService {
    
    private final BaseDecoderService baseDecoderService;
    private final LagrangeInterpolationService lagrangeInterpolationService;
    
    @Autowired
    public SecretSharingService(BaseDecoderService baseDecoderService,
<span class="fc" id="L28">                               LagrangeInterpolationService lagrangeInterpolationService) {</span>
<span class="fc" id="L29">        this.baseDecoderService = baseDecoderService;</span>
<span class="fc" id="L30">        this.lagrangeInterpolationService = lagrangeInterpolationService;</span>
<span class="fc" id="L31">    }</span>
    
    /**
     * Calculates the secret from a test case input
     * 
     * @param testCase the test case containing keys and root points
     * @return the secret response with calculated secret and metadata
     */
    public SecretResponse calculateSecret(TestCaseInput testCase) {
<span class="fc" id="L40">        long startTime = System.currentTimeMillis();</span>
        
        try {
            // Validate input
<span class="fc" id="L44">            validateTestCase(testCase);</span>
            
            // Get root points and decode them
<span class="fc" id="L47">            List&lt;RootPoint&gt; rootPoints = testCase.getRootPointsList();</span>
<span class="fc" id="L48">            log.info(&quot;Processing {} root points, need minimum {}&quot;, </span>
<span class="fc" id="L49">                    rootPoints.size(), testCase.getKeys().getK());</span>
            
            // Decode y-values from their respective bases
<span class="fc" id="L52">            List&lt;RootPoint&gt; decodedPoints = rootPoints.stream()</span>
<span class="fc" id="L53">                    .map(baseDecoderService::decodeRootPoint)</span>
<span class="fc" id="L54">                    .collect(Collectors.toList());</span>
            
            // Select k points for interpolation (use first k points)
<span class="fc" id="L57">            int k = testCase.getKeys().getK();</span>
<span class="fc" id="L58">            List&lt;RootPoint&gt; selectedPoints = decodedPoints.subList(0, k);</span>
            
            // Convert to interpolation points
<span class="fc" id="L61">            List&lt;LagrangeInterpolationService.Point&gt; interpolationPoints = </span>
<span class="fc" id="L62">                    selectedPoints.stream()</span>
<span class="fc" id="L63">                    .map(rp -&gt; new LagrangeInterpolationService.Point(rp.getX(), rp.getDecodedY()))</span>
<span class="fc" id="L64">                    .collect(Collectors.toList());</span>
            
            // Calculate the secret using Lagrange interpolation
<span class="fc" id="L67">            BigDecimal secretDecimal = lagrangeInterpolationService.calculateConstantTerm(interpolationPoints);</span>
<span class="fc" id="L68">            String secret = secretDecimal.toBigInteger().toString();</span>
            
            // Create response points
<span class="fc" id="L71">            List&lt;SecretResponse.DecodedPoint&gt; responsePoints = selectedPoints.stream()</span>
<span class="fc" id="L72">                    .map(rp -&gt; SecretResponse.DecodedPoint.builder()</span>
<span class="fc" id="L73">                            .x(rp.getX())</span>
<span class="fc" id="L74">                            .y(rp.getDecodedY())</span>
<span class="fc" id="L75">                            .originalBase(rp.getBase())</span>
<span class="fc" id="L76">                            .originalValue(rp.getValue())</span>
<span class="fc" id="L77">                            .build())</span>
<span class="fc" id="L78">                    .collect(Collectors.toList());</span>
            
<span class="fc" id="L80">            long processingTime = System.currentTimeMillis() - startTime;</span>
            
            // Create metadata
<span class="fc" id="L83">            SecretResponse.ProcessingMetadata metadata = SecretResponse.ProcessingMetadata.builder()</span>
<span class="fc" id="L84">                    .baseConversionsCount(selectedPoints.size())</span>
<span class="fc" id="L85">                    .precisionUsed(&quot;HIGH&quot;)</span>
<span class="fc" id="L86">                    .validationsPassed(3)</span>
<span class="fc" id="L87">                    .warnings(new ArrayList&lt;&gt;())</span>
<span class="fc" id="L88">                    .build();</span>
            
<span class="fc" id="L90">            SecretResponse response = SecretResponse.success(</span>
                    secret,
                    secretDecimal,
                    responsePoints,
<span class="fc" id="L94">                    testCase.getKeys().getPolynomialDegree(),</span>
<span class="fc" id="L95">                    testCase.getKeys().getN(),</span>
<span class="fc" id="L96">                    processingTime</span>
            );
<span class="fc" id="L98">            response.setMetadata(metadata);</span>
            
<span class="fc" id="L100">            log.info(&quot;Successfully calculated secret: {} in {}ms&quot;, secret, processingTime);</span>
<span class="fc" id="L101">            return response;</span>
            
<span class="fc" id="L103">        } catch (Exception e) {</span>
<span class="fc" id="L104">            long processingTime = System.currentTimeMillis() - startTime;</span>
<span class="fc" id="L105">            log.error(&quot;Error calculating secret: {}&quot;, e.getMessage(), e);</span>
<span class="fc" id="L106">            return SecretResponse.error(e.getMessage(), processingTime);</span>
        }
    }
    
    /**
     * Calculates secret using alternative point selection strategy
     * Uses different combinations of k points to verify consistency
     * 
     * @param testCase the test case
     * @return the secret response
     */
    public SecretResponse calculateSecretWithVerification(TestCaseInput testCase) {
<span class="fc" id="L118">        long startTime = System.currentTimeMillis();</span>
        
        try {
<span class="fc" id="L121">            validateTestCase(testCase);</span>
            
<span class="fc" id="L123">            List&lt;RootPoint&gt; rootPoints = testCase.getRootPointsList();</span>
<span class="fc" id="L124">            int k = testCase.getKeys().getK();</span>
<span class="fc" id="L125">            int n = testCase.getKeys().getN();</span>
            
            // Decode all points
<span class="fc" id="L128">            List&lt;RootPoint&gt; decodedPoints = rootPoints.stream()</span>
<span class="fc" id="L129">                    .map(baseDecoderService::decodeRootPoint)</span>
<span class="fc" id="L130">                    .collect(Collectors.toList());</span>
            
            // Try multiple combinations and verify they give the same result
<span class="fc" id="L133">            List&lt;String&gt; secrets = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L134">            List&lt;String&gt; warnings = new ArrayList&lt;&gt;();</span>
            
            // Test with first k points
<span class="fc" id="L137">            List&lt;RootPoint&gt; firstK = decodedPoints.subList(0, k);</span>
<span class="fc" id="L138">            BigDecimal secret1 = calculateSecretFromPoints(firstK);</span>
<span class="fc" id="L139">            secrets.add(secret1.toBigInteger().toString());</span>
            
            // If we have extra points, test with alternative combinations
<span class="pc bpc" id="L142" title="1 of 2 branches missed.">            if (n &gt; k) {</span>
                // Try with last k points
<span class="fc" id="L144">                List&lt;RootPoint&gt; lastK = decodedPoints.subList(n - k, n);</span>
<span class="fc" id="L145">                BigDecimal secret2 = calculateSecretFromPoints(lastK);</span>
<span class="fc" id="L146">                secrets.add(secret2.toBigInteger().toString());</span>
                
                // Compare results
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">                if (!secret1.equals(secret2)) {</span>
<span class="nc" id="L150">                    warnings.add(&quot;Different point combinations yielded different secrets - possible data inconsistency&quot;);</span>
<span class="nc" id="L151">                    log.warn(&quot;Secret verification failed: {} vs {}&quot;, secret1, secret2);</span>
                }
            }
            
            // Use the first calculated secret
<span class="fc" id="L156">            BigDecimal finalSecret = secret1;</span>
<span class="fc" id="L157">            String secretString = finalSecret.toBigInteger().toString();</span>
            
            // Create response
<span class="fc" id="L160">            List&lt;SecretResponse.DecodedPoint&gt; responsePoints = firstK.stream()</span>
<span class="fc" id="L161">                    .map(rp -&gt; SecretResponse.DecodedPoint.builder()</span>
<span class="fc" id="L162">                            .x(rp.getX())</span>
<span class="fc" id="L163">                            .y(rp.getDecodedY())</span>
<span class="fc" id="L164">                            .originalBase(rp.getBase())</span>
<span class="fc" id="L165">                            .originalValue(rp.getValue())</span>
<span class="fc" id="L166">                            .build())</span>
<span class="fc" id="L167">                    .collect(Collectors.toList());</span>
            
<span class="fc" id="L169">            long processingTime = System.currentTimeMillis() - startTime;</span>
            
<span class="fc" id="L171">            SecretResponse.ProcessingMetadata metadata = SecretResponse.ProcessingMetadata.builder()</span>
<span class="fc" id="L172">                    .baseConversionsCount(decodedPoints.size())</span>
<span class="fc" id="L173">                    .precisionUsed(&quot;HIGH&quot;)</span>
<span class="pc bpc" id="L174" title="1 of 2 branches missed.">                    .validationsPassed(warnings.isEmpty() ? 4 : 3)</span>
<span class="fc" id="L175">                    .warnings(warnings)</span>
<span class="fc" id="L176">                    .build();</span>
            
<span class="fc" id="L178">            SecretResponse response = SecretResponse.success(</span>
                    secretString,
                    finalSecret,
                    responsePoints,
<span class="fc" id="L182">                    testCase.getKeys().getPolynomialDegree(),</span>
<span class="fc" id="L183">                    testCase.getKeys().getN(),</span>
<span class="fc" id="L184">                    processingTime</span>
            );
<span class="fc" id="L186">            response.setMetadata(metadata);</span>
            
<span class="fc" id="L188">            log.info(&quot;Calculated secret with verification: {} in {}ms&quot;, secretString, processingTime);</span>
<span class="fc" id="L189">            return response;</span>
            
<span class="nc" id="L191">        } catch (Exception e) {</span>
<span class="nc" id="L192">            long processingTime = System.currentTimeMillis() - startTime;</span>
<span class="nc" id="L193">            log.error(&quot;Error in verified secret calculation: {}&quot;, e.getMessage(), e);</span>
<span class="nc" id="L194">            return SecretResponse.error(e.getMessage(), processingTime);</span>
        }
    }
    
    /**
     * Helper method to calculate secret from a list of root points
     */
    private BigDecimal calculateSecretFromPoints(List&lt;RootPoint&gt; points) {
<span class="fc" id="L202">        List&lt;LagrangeInterpolationService.Point&gt; interpolationPoints = points.stream()</span>
<span class="fc" id="L203">                .map(rp -&gt; new LagrangeInterpolationService.Point(rp.getX(), rp.getDecodedY()))</span>
<span class="fc" id="L204">                .collect(Collectors.toList());</span>
        
<span class="fc" id="L206">        return lagrangeInterpolationService.calculateConstantTerm(interpolationPoints);</span>
    }
    
    /**
     * Validates the test case input
     */
    private void validateTestCase(TestCaseInput testCase) {
<span class="fc bfc" id="L213" title="All 2 branches covered.">        if (testCase == null) {</span>
<span class="fc" id="L214">            throw new IllegalArgumentException(&quot;Test case cannot be null&quot;);</span>
        }
        
<span class="pc bpc" id="L217" title="1 of 2 branches missed.">        if (testCase.getKeys() == null) {</span>
<span class="nc" id="L218">            throw new IllegalArgumentException(&quot;Keys section is required&quot;);</span>
        }
        
<span class="fc bfc" id="L221" title="All 2 branches covered.">        if (!testCase.getKeys().isValid()) {</span>
<span class="fc" id="L222">            throw new IllegalArgumentException(&quot;Invalid keys: k must be &lt;= n and both must be positive&quot;);</span>
        }
        
<span class="fc" id="L225">        List&lt;RootPoint&gt; rootPoints = testCase.getRootPointsList();</span>
<span class="pc bpc" id="L226" title="1 of 2 branches missed.">        if (rootPoints.size() != testCase.getKeys().getN()) {</span>
<span class="nc" id="L227">            throw new IllegalArgumentException(</span>
<span class="nc" id="L228">                String.format(&quot;Expected %d root points but found %d&quot;, </span>
<span class="nc" id="L229">                            testCase.getKeys().getN(), rootPoints.size()));</span>
        }
        
<span class="pc bpc" id="L232" title="1 of 2 branches missed.">        if (rootPoints.size() &lt; testCase.getKeys().getK()) {</span>
<span class="nc" id="L233">            throw new IllegalArgumentException(</span>
<span class="nc" id="L234">                String.format(&quot;Need at least %d points but only have %d&quot;, </span>
<span class="nc" id="L235">                            testCase.getKeys().getK(), rootPoints.size()));</span>
        }
        
        // Validate each root point
<span class="fc bfc" id="L239" title="All 2 branches covered.">        for (RootPoint point : rootPoints) {</span>
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">            if (point == null) {</span>
<span class="nc" id="L241">                throw new IllegalArgumentException(&quot;Root point cannot be null&quot;);</span>
            }
<span class="pc bpc" id="L243" title="1 of 2 branches missed.">            if (!point.isValidValueForBase()) {</span>
<span class="nc" id="L244">                throw new IllegalArgumentException(</span>
<span class="nc" id="L245">                    String.format(&quot;Invalid value '%s' for base %s at x=%d&quot;, </span>
<span class="nc" id="L246">                                point.getValue(), point.getBase(), point.getX()));</span>
            }
<span class="fc" id="L248">        }</span>
<span class="fc" id="L249">    }</span>
    
    /**
     * Gets algorithm information
     * 
     * @return algorithm details
     */
    public String getAlgorithmInfo() {
<span class="fc" id="L257">        return &quot;Shamir's Secret Sharing with Lagrange Interpolation - &quot; +</span>
               &quot;Reconstructs polynomial constant term from k out of n encoded points&quot;;
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>